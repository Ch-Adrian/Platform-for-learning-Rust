{"cargoToml":"[package]\nname \u003d \"main\"\nversion \u003d \"0.1.0\"\nedition \u003d \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]","pages":[{"sections":[{"title":"Pierwszy program w Rust","cells":[{"type":"TextCell","value":"Wykonaj swój pierwszy program w języku Rust klikając przycisk \u0027Uruchom\u0027.\n\nW poniższym kodzie jest zaprezentowana główna funkcja o nazwie `main`, która jest punktem początkowym programu w języku Rust. Słowo kluczowe `fn` deklaruje poniższą funkcję. Wewnątrz niej jest wywołana inna funkcja `println!`,  która wypisuje tekst na wyjście."},{"type":"CodeCell","value":"fn main() {\n\tprintln!(\"Hello World!\");\n}"},{"tiles":[{"id":1,"text":"Jeden Kafelek"},{"id":2,"text":"Drugi Kafelek"},{"id":3,"text":"Trzeci Kaflek"}],"type":"TilesCell","value":"To jest kom�rka typu kafelki!"}]},{"title":"Zmienne","cells":[{"type":"TextCell","value":"## Typy zmiennych\nJęzyk Rust posiada różne typy zmiennych.  Można je podzielić na poniższe kategorie:\n\n1. Integer, np. i8, i16, i32, i64, i128, u8, u16, u64, u128, u-unsigned, i-signed. Jest to typ liczby całkowitej.\n2. Floating-point, np. f32, f64. Jest to typ liczby zmiennoprzecinkowej.\n3. Boolean, np. bool (true, false). Jes to typ wartości prawda/fałsz.\n4. Character, np. char. Jest to typ pojedynczego znaku.\n5. String, np. String, \u0026str. Jest to typ napisu."},{"type":"TextCell","value":"## Tworzenie zmiennej\nDo stworzenia zmiennej służy słowo kluczowe `let`. Domyślnie nie można modyfikować ich wartości, aby to zrobić trzeba dodać słowo kluczowe `mut`.\n\n```\nfn main(){\n    let num \u003d 0; // zmienna niemodyfikowalna\n    let mut num2 \u003d 1; // zmienna modyfikowalna\n}\n```\n\nRównież jest możliwość tworzenia stałej za pomocą `const`. W tym wypadku podanie typu jest obowiązkowe. W języku Rust istnieje zasada tworzenia stałych z wielkich liter. \n\n```\nconst AMOUNT: i32 \u003d 10;\n```"},{"type":"TextCell","value":"## Komentarze\nAby dodać komentarz poprzedź miejsce do wykomentowania napisem: `//` lub otocz napisami `/*` i `*/`."},{"type":"TextCell","value":"## Zadania"},{"mutableString":"/*TO_FILL*/","template":"fn main() {\r\n\tlet _a \u003d 2.0; //f64\r\n    let _b: /*TO_FILL*/ \u003d 3.0; // f32\r\n\tlet _c: /*TO_FILL*/ \u003d true;\r\n\tlet _d: /*TO_FILL*/ \u003d \u0027A\u0027;\r\n\tlet _e: /*TO_FILL*/ \u003d 1;\r\n\tlet mut _string: /*TO_FILL*/ \u003d String::from(\"this is string\");\r\n\tprintln!(\"{_a} {_b} {_c} {_d} {_string}\");\r\n}","reference":"fn main() {\n\tlet _a \u003d 2.0; //f64\n    let _b: f32 \u003d 3.0; // f32\n\tlet _c: bool \u003d true;\n\tlet _d: char \u003d \u0027A\u0027;\n\tlet _e: i32 \u003d 1;\n\tlet mut _string: String \u003d String::from(\"this is string\");\n    println!(\"{_a} {_b} {_c} {_d} {_string}\");\n}","type":"ImmutableCodeCell","value":"fn main() {\r\n\tlet _a \u003d 2.0; //f64\r\n    let _b: /*TO_FILL*/ \u003d 3.0; // f32\r\n\tlet _c: /*TO_FILL*/ \u003d true;\r\n\tlet _d: /*TO_FILL*/ \u003d \u0027A\u0027;\r\n\tlet _e: /*TO_FILL*/ \u003d 1;\r\n\tlet mut _string: /*TO_FILL*/ \u003d String::from(\"this is string\");\r\n\tprintln!(\"{_a} {_b} {_c} {_d} {_string}\");\r\n}"},{"options":[{"id":0,"text":"f32","valid":false},{"id":1,"text":"f64","valid":true},{"id":2,"text":"u128","valid":false}],"type":"QuizCell","value":"Jaki typ ma zmienna `_zm` w deklaracji: `let _zm \u003d 2.0;` ?"},{"options":[{"id":0,"text":"tak","valid":false},{"id":1,"text":"nie","valid":true}],"type":"QuizCell","value":"Czy zmienne zadeklarowane tylko słowem kluczowym `let` np. `let _a \u003d 1;` mogą być modyfikowalne?"},{"options":[{"id":0,"text":"tak","valid":true},{"id":1,"text":"nie","valid":false}],"type":"QuizCell","value":"Czy deklarowanie stałej zmiennej słowem kluczowym `const` wymaga podania jej typu?"},{"type":"TextCell","value":"## Typy złożone"},{"type":"TextCell","value":"### Tuple\n\nTupla (inaczej krotka) to typ, który potrafi przechowywać wiele danych różnego typu.\n\nBy stworzyć tuplę należy podać wartości w nawiasach `()`. Wartości można wyciągnąć za pomocą `.` np.\n```\nlet tup \u003d (1, 2.0, 100);\nlet one \u003d tup.0;\n```\nWartości można również wyciągać poprzez przyrównanie tupli do zmiennych w nawiasach. np.:\n```\nlet (a,b,c) \u003d tup;\nlet _one \u003d a;\n```\n"},{"type":"TextCell","value":"### Tablice\n\nTablica to kolekcja, która posiada wiele danych jednego typu.\n\nMożna ją stworzyć za pomocą nawiasów prostokątnych `[]` np.\n```\nlet arr \u003d [1,2,3,4,5];\n```\ni wyciągać z niej elementy również poprzez ten sam operator `[]`:\n```\nlet one \u003d arr[0];\n```\n\nGdy chcemy zadeklarować tablicę jedną wartością o konkretnej długości można podać odpowiednio dwie liczby w `[]` oddzielone `;`. np.:\n```\nlet arr \u003d [0; 5];\n```\nPowyższy przykład tworzy tablicę z pięcioma zerami, czyli [0,0,0,0,0]."}]},{"title":"Funkcje","cells":[{"type":"TextCell","value":"Słowem kluczowym do tworzenia funkcji w języku Rust jest `fn`.  Funkcję można tworzyć przykładowo w ten sposób:\n\n```\nfn nazwa_funkcji(){\n    // to jest wnętrze jakiejś funkcji\n}\n```\nW nawiasach można podać parametry wraz z ich typami:\n```\nfn nazwa_funkcji(num: i32, c: char){\n    // to jest wnętrze jakiejś funkcji\n}\n```\njeżeli chcemy zwrócić jakąś wartość używamy słowa kluczowego `return` lub jeśli chcemy zwrócić wartość na samym końcu funkcji to wystarczy zostawić ją bez średnika. By ustalić typ zwracanej wartości zaraz po nazwie funkcji dodajemy `-\u003e` i piszemy typ.\n```\nfn nazwa_funkcji(num: i32, c: char) -\u003e i32 {\n    5\n}\n```\n"},{"type":"TextCell","value":"## Zadania"},{"options":[{"id":0,"text":"tak","valid":false},{"id":1,"text":"nie","valid":true}],"type":"QuizCell","value":"Czy zawsze trzeba używać słowa kluczowego `return` do zwracania wartości z funkcji?"},{"type":"TextCell","value":"Uzupełnij funkcję `add_two` tak, aby dodawała 2 do swojego argumentu i zwracała odpowiedni wynik."},{"test":"#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn it_adds_two() {\r\n        assert_eq!(3, add_two(1));\r\n    }\r\n}","reference":"pub fn add_two(a: i32) -\u003e i32 {\r\n    a + 2\r\n}","type":"CodeCell","value":"pub fn add_two(a: i32) -\u003e i32 {\r\n\r\n}\r\n\r\nfn main(){\r\n    println!(\"Result: {}\", add_two(1));\r\n}"}]}]},{"sections":[{"title":"Sterowanie programem","cells":[{"type":"TextCell","value":"##  Wyrażenie warunkowe\nW języku Rust podobnie jak w innych językach programem można sterować za pomocą wyrażenia warunkowego if/else. Posiada ono konstrukcję jak poniżej:\n```\nif warunek {\n    println!(\"First if\");\n} else {\n    println!(\"Second if\");\n}\n```\n\nW miejsce \u0027warunek\u0027 musi znajdować się wartość o typie bool - w innym wypadku program wyrzuci wyjątek. Nie trzeba natomiast umieszczać go w nawiasach, jak robi się to w innych językach np. Java, C++."},{"type":"TextCell","value":"Wyrażenie `if` występuje również w zwięzłej formie. Jeśli chcemy przkazać jakiś wynik w zależności od warunku możemy to wykonć w ten sposób:\n\n`let num \u003d if warunek { 1 } else { 2 };`\n\nJeśli `warunek` posiada wartość `true` to zwracana jest wartość z pierwszego nawiasu klamrowego od lewej. W przeciwynym wypadku wartość z drugiego nawiasu klamrowego.\n\nUwaga! Typ zwracanych wartości w obu przypadkach musi być ten sam.\n\nSpróbuj wykonać poniższy kod."},{"type":"CodeCell","value":"fn main() {\n    let cond \u003d false;\n    let num \u003d if cond { 1 } else { 2 };\n    \n    println!(\"The value of number is: {num}\");\n}"},{"type":"TextCell","value":"## Zadania"},{"options":[{"id":0,"text":"TAK","valid":false},{"id":1,"text":"NIE","valid":true}],"type":"QuizCell","value":"Czy są potrzebne nawiasy w warunku `if`?"},{"options":[{"id":0,"text":"Program skompiluje się poprawnie i wykona.","valid":false},{"id":1,"text":"Program nie wykona się i wyrzuci wyjątek.","valid":true},{"id":2,"text":"Żadna opcja z powyższych.","valid":false}],"type":"QuizCell","value":"Jaki będzie efekt wykonania programu, gdy wyrażenie warunkowe będzie miało typ int?"},{"type":"TextCell","value":"W poniższym zadaniu uzupełnij kod w miejscach, gdzie występuje /\\*TO_FILL\\*/, aby się poprawnie kompilował i był zgodny z wypisywanymi zdaniami."},{"mutableString":"/*TO_FILL*/","template":"fn main() {\r\n    let num \u003d 6;\r\n\r\n    if /*TO_FILL*/ {\r\n        println!(\"num can be divided by 4\");\r\n    } else if /*TO_FILL*/ {\r\n        println!(\"num can be divided by 3\");\r\n    } else if /*TO_FILL*/ {\r\n        println!(\"num can be divided by 2\");\r\n    } else {\r\n        println!(\"num can be divided by 4 and 3 and 2\");\r\n    }\r\n}","reference":"fn main() {\r\n    let number \u003d 6;\r\n\r\n    if number % 4 \u003d\u003d 0 {\r\n        println!(\"number is divisible by 4\");\r\n    } else if number % 3 \u003d\u003d 0 {\r\n        println!(\"number is divisible by 3\");\r\n    } else if number % 2 \u003d\u003d 0 {\r\n        println!(\"number is divisible by 2\");\r\n    } else {\r\n        println!(\"number is not divisible by 4, 3, or 2\");\r\n    }\r\n}","type":"ImmutableCodeCell","value":"fn main() {\r\n    let num \u003d 6;\r\n\r\n    if /*TO_FILL*/ {\r\n        println!(\"num can be divided by 4\");\r\n    } else if /*TO_FILL*/ {\r\n        println!(\"num can be divided by 3\");\r\n    } else if /*TO_FILL*/ {\r\n        println!(\"num can be divided by 2\");\r\n    } else {\r\n        println!(\"num can be divided by 4 and 3 and 2\");\r\n    }\r\n}"},{"options":[{"id":0,"text":"let num \u003d if true { 1 } else { \"two\" };","valid":false},{"id":1,"text":"if ( 1%2 \u003d\u003d 0 ) { println!(\"0\"); } else { println!(\"1\"); }","valid":true},{"id":2,"text":"let num \u003d if true { 1 } else { 2 };","valid":true}],"type":"QuizCell","value":"Które wyrażenie skompiluje się poprawnie?"},{"tiles":[{"id":1,"text":"Jeden Kafelek"},{"id":2,"text":"Drugi Kafelek"},{"id":3,"text":"Trzeci Kaflek"}],"type":"TilesCell","value":"To jest kom�rka typu kafelki!"}]},{"title":"Pętle","cells":[{"type":"TextCell","value":"Czasami programista potrzebuje wykonać fragment kodu kilkakrotnie. W języku Rust występuje kilka rodzajów pętli, które potrafią wykonać taką funkcjonalność.\n\n1. Pętla loop, jeśli nie jest zatrzymana, wykonuję blok kodu w nieskończoność. Zatrzymać ją można za pomocą break.\n2. Pętla while, posiada wyrażenie warunkowe i powtarza blok kodu dopóki warunek jest spełniony.\n3. Pętla for, iteruje po elementach pewnej kolekcji. Powtarza blok kodu tyle razy ile wynosi rozmiar kolekcji."},{"type":"TextCell","value":"Poniższy program pokazuje wykonanie pętli `loop`, aż do wywołania słowa kluczowego `break`.\n`break` również potrafi zwracać pewną wartość, która jest przekazywana do zmiennej `res`."},{"type":"CodeCell","value":"fn main() {\r\n    \r\n    let mut cnt \u003d 0;\r\n\r\n    let res \u003d loop {\r\n        cnt +\u003d 1;\r\n\r\n        if cnt \u003d\u003d 5 {\r\n            break cnt\r\n        }\r\n    };\r\n\r\n    println!(\"The result: {res}\");\r\n\r\n}"},{"type":"TextCell","value":"Poniższy kod pokazuje wykonanie pętli while, gdzie w wyrażeniu warunkowym jest pokazane odliczanie do 5."},{"type":"CodeCell","value":"fn main() {\r\n\tlet mut num \u003d 5;\r\n\r\n    while num !\u003d 0 {\r\n        println!(\"This is line with num: {num}\");\r\n        num -\u003d 1;\r\n    }\r\n}"},{"type":"TextCell","value":"Poniższy program pokazuje trzy wykonania pętli `for`. \n\n1. Pierwsze wykonanie przechodzi przez kolekcję collection i wypisuje jej elementy. \n2. Drugie wywołanie dolicza od 1 do maksymalnej wartości przekazanej.\n3. Trzecie wykonanie za pomocą metody rev wypisuje ciąg w odwrotnej kolejności."},{"type":"CodeCell","value":"fn main() {\r\n\r\n    print_collection();\r\n    count_up_to_(5);\r\n    count_down_from_(5);\r\n\r\n}\r\n\r\nfn print_collection(){\r\n    println!(\"Printing collection:\");\r\n\tlet collection \u003d [1,2,3,4,5];\r\n\r\n    for e in collection {\r\n        println!(\"Element: {e}\");\r\n    }\r\n    println!(\"\");\r\n}\r\n\r\nfn count_up_to_(max: i32){\r\n    println!(\"Increasing order: \");\r\n    for num in 1..max+1 {\r\n        println!(\"Number: {num}.\")\r\n    }\r\n    println!(\"\");\r\n}\r\n\r\nfn count_down_from_(max: i32){\r\n    println!(\"Reversed order: \");\r\n    for num in (1..max+1).rev() {\r\n        println!(\"Number: {num}.\")\r\n    }\r\n    println!(\"\");\r\n}\r\n"},{"type":"TextCell","value":"## Zadania"},{"type":"TextCell","value":"Napisz nową funkcję o nazwie `count`, która wykona funkcję `inc` 100 razy."},{"test":"\n#[cfg(test)]\nmod tests {\n    use crate::count;\n    use crate::COUNTER;\n\n    #[test]\n    fn check_counter_value_after_executing_count() {\n        unsafe {\n            assert_eq!(COUNTER, 0);\n        }\n        count();\n        unsafe {\n            assert_eq!(COUNTER, 100);\n        }\n    }\n}","reference":"static mut COUNTER: i32 \u003d 0;\n\nfn main() {\n}\n\nfn inc(){\n    unsafe{\n        COUNTER +\u003d 1;\n    }\n}\n\npub fn count(){\n    for _i in 1..101 {\n        inc();\n    }\n}","type":"CodeCell","value":"static mut COUNTER: i32 \u003d 0;\r\n\r\nfn main() {}\r\n\r\nfn inc(){\r\n    unsafe{\r\n        COUNTER +\u003d 1;\r\n    }\r\n}\r\n"}]}]},{"sections":[{"title":"Prawo własności","cells":[{"type":"TextCell","value":"Ownership, czyli prawo własności w języku Rust to mechanizm do zarządzania pamięcią. W innych językach pamięć może być zarządzana za pomocą garbage collector-a lub jest alokowana osobno przez programistę. Rozwiązanie w języku Rust jest pomiędzy tymi dwoma. Programista sam zarządza pamięcią, ale kompilator za pomocą odpowiednich zasad pilnuje, aby było to bezpieczne.\n\nZasady prawa własności:\n\n1. Każda wartość posiada właściciela.\n2. Może być tylko jeden właściciel dla każdej wartości.\n3. Kiedy właściciel wychodzi poza zakres, wywoływana jest funkcja drop, która ma za zadanie zwalniać pamięć alokowaną dla posiadanej wartości.\n\nAby zobrazować działanie potrzebny jest typ alokowany na stercie. Typ `String` za pomocą metody `from` zwraca odpowiednią wartość. np.:\n```\nlet str1 \u003d String::from(\"string\");\nlet str2 \u003d str1;\n```\nW pierwszej linijce str1 posiada prawo do własności nad pamięcią alokowaną przez String::from. Natomiast w kolejnej linijce prawo przejmuje zmienna str2 i od tej linijki zmienna str1 nie może używać danego jej poprzednio napisu.\n\n\n"},{"type":"TextCell","value":"Wykonaj poniższy kod i sprawdź rezultat."},{"type":"CodeCell","value":"fn main() {\r\n    let str1 \u003d String::from(\"string\");\r\n    let str2 \u003d str1;\r\n\r\n    println!(\"{str1} and {str2}\");\r\n}"},{"type":"TextCell","value":"Aby przekazać wartość do innej zmiennej, by zachować obie należy stworzyć kopię za pomocą metody `clone()`."},{"type":"CodeCell","value":"fn main() {\r\n    let str1 \u003d String::from(\"string\");\r\n    let str2 \u003d str1.clone();\r\n\r\n    println!(\"{str1} and {str2}\");\r\n}"},{"type":"TextCell","value":"Typy proste jak integer, float, char itp. Nie potrzebują być przedmiotem mechanizmu prawa własności, ponieważ ich typ jest ustalony w czasie kompilacji, a kopia wykonywana jest automatycznie."},{"type":"CodeCell","value":"fn main() {\r\n\tlet a: u32 \u003d 10;\r\n    let b: u32 \u003d a;\r\n\r\n    println!(\"{a} and {b}\");\r\n}"},{"type":"TextCell","value":"Prawa własności podobnie obowiązują dla funkcji kiedy zmienną przekazujemy jako parametr."},{"type":"CodeCell","value":"fn main() {\r\n\tlet str1 \u003d String::from(\"I want to be in a function\");\r\n\r\n    let str3 \u003d function(str1);\r\n\r\n    // println!(\"in main: {str1}\");  // this line gives an error\r\n    println!(\"back in main: {str3}\");\r\n}\r\n\r\nfn function(str2: String) -\u003e String {\r\n    println!(\"in function: {str2}\");\r\n    str2\r\n}"},{"type":"TextCell","value":"## Zadanie"},{"options":[{"id":0,"text":"tak","valid":false},{"id":1,"text":"nie","valid":true}],"type":"QuizCell","value":"Czy zmienne typu prostego podlegają prawu własności?"}]},{"title":"Referencje","cells":[{"type":"TextCell","value":"Referencja to zmienna, która zamiast przejmować prawo własności tylko pożycza własność. Dzięki niej zmienna z prawem własności cały czas je posiada, a obie zmienne czerpią korzyści z dostępu do zaalokowanej pamięci. Referencje tworzy się za pomocą `\u0026`. np.:\n```\nlet str1 \u003d String::from(\"string\");\nlet str2: \u0026String \u003d \u0026str1;\n```\n\nReferencje posiadają parę praw:\n\n1. W danym zakresie może być albo wiele referencji niemutowalnych albo jedna referencja mutowalna.\n2. Referencje muszą być zawsze ważne. Nie może być wiszących referencji.\n\n"},{"type":"CodeCell","value":"fn main() {\r\n\tlet str1 \u003d String::from(\"string\");\r\n    ref_function(\u0026str1);\r\n    println!(\"\");\r\n    println!(\"Inside main function: {str1}\");\r\n}\r\n\r\nfn ref_function(ref1: \u0026String){\r\n    println!(\"Inside ref_function: {ref1}\");\r\n}"},{"type":"TextCell","value":"Niestety nie możemy zapożyczonych zmiennych modyfikować jeśli nie są zadeklarowane jako modyfikowalne np.\n```\nlet str1 \u003d String::from(\"string\");\nlet str2: \u0026String \u003d \u0026str1;\nstr2.push_str(\" nie można modyfikować\");\n```\n\nModyfikowalne zmienne deklarowane są słowem kluczowym `mut` np.\n```\nlet mut str1 \u003d String::from(\"string\");\nlet m_ref: \u0026mut String \u003d \u0026str1;\n```\n\nTeraz str2 może wpływac na wartość zmiennej str1. NIestety nie można stworzyć więcej zmiennych modyfikowalnych niż jedna dla jednej zmiennej w danym zakresie np.\n\n```\nlet mut str1 \u003d String::from(\"string\");\nlet ref1 \u003d \u0026str1;\nlet ref2 \u003d \u0026str1;\n\nprintln!(\"{ref1} and {ref2}\");\n\nlet m_ref: \u0026mut String \u003d \u0026mut str1;\n```"},{"type":"CodeCell","value":"fn main() {\r\n\tlet mut str1 \u003d String::from(\"string\");\r\n    let ref1 \u003d \u0026str1;\r\n    let ref2 \u003d \u0026str1;\r\n\r\n    println!(\"{ref1} and {ref2}\");\r\n\r\n    let m_ref: \u0026mut String \u003d \u0026mut str1;\r\n    println!(\"mut ref: {m_ref}\");\r\n}"},{"type":"TextCell","value":"Czasami mogą powstać wiszące referencje w programie, które wskazują na już zwolnioną pamięć jakiejś zmiennej. Jeśli powstaną takie referencje program zwróci błąd i się nie wykona."},{"type":"CodeCell","value":"fn main() {\r\n\tlet r_str \u003d dangle_ref();\r\n}\r\n\r\nfn dangle_ref() -\u003e \u0026String {\r\n    let str1 \u003d String::from(\"string\");\r\n    \u0026str1\r\n}"},{"type":"TextCell","value":"## Zadanie"},{"mutableString":"/*TO_FILL*/","template":"fn main() {\r\n    let s1 \u003d String::from(\"hello\");\r\n\r\n    let len \u003d calculate_length(/*TO_FILL*/);\r\n\r\n    println!(\"The length of \u0027{}\u0027 is {}.\", s1, len);\r\n}\r\n\r\nfn calculate_length(s: \u0026String) -\u003e usize {\r\n    s.len()\r\n}","reference":"fn main() {\n    let s1 \u003d String::from(\"hello\");\n\n    let len \u003d calculate_length(\u0026s1);\n\n    println!(\"The length of \u0027{}\u0027 is {}.\", s1, len);\n}\n\nfn calculate_length(s: \u0026String) -\u003e usize {\n    s.len()\n}","type":"ImmutableCodeCell","value":"fn main() {\r\n    let s1 \u003d String::from(\"hello\");\r\n\r\n    let len \u003d calculate_length(/*TO_FILL*/);\r\n\r\n    println!(\"The length of \u0027{}\u0027 is {}.\", s1, len);\r\n}\r\n\r\nfn calculate_length(s: \u0026String) -\u003e usize {\r\n    s.len()\r\n}"}]}]}]}