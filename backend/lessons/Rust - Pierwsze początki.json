{"pages":[{"sections":[{"title":"Pierwszy program w Rust","cells":[{"type":"code","value":"fn main() {\r\n\tprintln!(\"hello world\");\r\n}"}]},{"title":"Zmienne i stałe","cells":[{"type":"text","value":"## Zmienne i stałe\nŹródło: https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html\n\n### Zmienne i ich przesłanianie (ang. variables and shadowed variables)\nDomyślnie wszystkie zmienne są niemutowalne (*immutable*), ale mogą być przesłaniane (*shadowed*). Nazwy zmiennycch w snake_case, można wykorzystać inferencje typów.\n"},{"type":"code","value":"fn main(){\r\n    let guess : u32 \u003d 12;\r\n}"},{"type":"text","value":"Nie można przypisać nowej wartości\n"},{"type":"code","value":"fn main(){\r\n    let guess : u32 \u003d 12;\r\n    guess \u003d 6; // error\r\n}"},{"type":"text","value":"Przesłanianie / nadpisywanie zmiennych:"},{"type":"code","value":"fn main(){\r\n    let spaces \u003d \"    \"; // inferencja typów\r\n\r\n    let spaces \u003d spaces.len();\r\n}"},{"type":"text","value":"Zmienne mutowalne (słowo kluczowe `mut`):"},{"type":"code","value":"fn main(){\r\n    let mut guess : u32 \u003d 12;\r\n    guess \u003d 6;\r\n}"},{"type":"text","value":"\u003e [!INFO] Zmienne mutowalne vs. redefiniowanie zmiennych\n\u003e Różnica pomiędzy przesłanianiem (redefiniowaniem) zmiennych a zmiennymi mutowalnymi.\n\u003e Shadowing is different from marking a variable as `mut`, because we’ll get a compile-time error if we accidentally try to reassign to this variable without using the `let` keyword. By using `let`, we can perform a few transformations on a value but have the variable be immutable after those transformations have been completed.\n\u003e The other difference between `mut` and shadowing is that because we’re effectively creating a new variable when we use the `let` keyword again, we can change the type of the value but reuse the same name.\n"},{"type":"code","value":"fn main() { \r\n\tlet x \u003d 5; \r\n\tlet x \u003d x + 1; \r\n\t{ \r\n\t\tlet x \u003d x * 2; \r\n\t\tprintln!(\"The value of x in the inner scope is: {}\", x); \r\n\t} \r\n\t\r\n\tprintln!(\"The value of x is: {}\", x); \r\n}\r\n"},{"type":"text","value":"\u003e [!QUESTION]\n\u003e - Kiedy zadziała inferencja typów?\n\u003e - Jakie są dozwolone znaki w nazwach zmiennych?\n\n"},{"type":"text","value":"### Stałe (ang. contants)"},{"type":"code","value":"fn main(){\r\n    const DB_PORT : u32 \u003d 5432;\r\n}"},{"type":"text","value":"Zgoodnie z konwencją nazwy stałych pisane są dużymi literami (SCREAMING_SNAKE_CASE).\n\nRóżnice pomiędzy zmiennymi i stałymi:\n- stałe nie mogą być mutowalne (sic!)\n- przy definicji stałej zawsze należy podać typ wartości\n- stałe mogą być zdefiniowane w dowolnym zasięgu, również w zasięgu globalnym,\n- wartością stałej może być tylko stałe wyrażenie, którego wartość jest znana na etapie kompilacji (więcej https://doc.rust-lang.org/reference/const_eval.html)\n"}]},{"title":"Podstawowe typy danych","cells":[{"type":"text","value":"\n\n## Podstawowe typy danych\n\nŹródło: https://doc.rust-lang.org/book/ch03-02-data-types.html\n\nRust jest językiem **statycznie typowanym**, co oznacza, że każda wartość posiada swój typ, zdefiniowany na etapie kompilacji. Rust posiada mechanizm inferencji typów, który oznacza, że kompilator stara się \"domyślić\" typu na podstawie danej wartości, np.:\n"},{"type":"code","value":"fn main(){\r\n    let x \u003d 5 + 5; // i32\r\n}"},{"type":"text","value":"Inferencja nie działa zawsze, np. w przypadku parsowania wartości konieczne jest podanie konkretnego typu:\n"},{"type":"code","value":"fn main(){\r\n    let x: u32 \u003d \"432\".parse().expect(\"Wrong number!\");\r\n}"},{"type":"text","value":"\nSpróbuj usunąć definicję typu i skompilować kod.\n\nPodobnie jak w innych językach wyróżnia się typy proste (ang. *scalar types*) i typy złożone (ang. *compound types*).\n\n"},{"type":"text","value":"### Typy proste\n\n\n-----------\n\n\n\n#### Liczby całkowite \n\nRust, podobnie jak np. C, posiada wiele typów całkowitych, różniących się rozmiarem (liczbą bajtów przeznaczonych na reprezentację liczby) oraz zakresem (unsigned \u0026 signed).\n\n| Length  | Signed | Unsigned |\n|---------|--------|----------|\n| 8-bit   | i8     | u8       |\n| 16-bit  | i16    | u16      |\n| 32-bit  | i32    | u32      |\n| 64-bit  | i64    | u64      |\n| 128-bit | i128   | u128     |\n| arch    | isize  | usize    |\n\nRóżne sposoby zapisu wartości liczbowych\n"},{"type":"code","value":"fn main(){\r\n    let d1 \u003d 98222; // decimal\r\n    let d2 \u003d 98_222; //  _ is a visual separator\r\n    let h \u003d 0xff; // hex\r\n    let o \u003d 0o77; // octal\r\n    let b \u003d 0b1111_0000; // binary\r\n    let x \u003d b\u0027A\u0027; // byte (only for u8)\r\n}\r\n"},{"type":"text","value":"Możliwe jest nadpisywanie domyślnego typu wartości za pomocą przyrostka:\n"},{"type":"code","value":"fn main(){\r\n    let big_x \u003d 1000u64;\r\n    let small_y \u003d 5_u8;\r\n}"},{"type":"text","value":"### Liczby zmiennoprzecinkowe"},{"type":"code","value":"fn main() {     \r\n\tlet x \u003d 2.0; // f64, default\r\n\tlet y: f32 \u003d 3.0; // f32 \r\n}"},{"type":"text","value":"### Operacje na liczbach"},{"type":"code","value":"fn main() { \r\n\t// addition \r\n\tlet sum \u003d 5 + 10; \r\n\t\r\n\t// subtraction \r\n\tlet difference \u003d 95.5 - 4.3; \r\n\t\r\n\t// multiplication \r\n\tlet product \u003d 4 * 30; \r\n\t\r\n\t// division \r\n\tlet quotient \u003d 56.7 / 32.2; \r\n\tlet truncated \u003d -5 / 3; // Results in -1 \r\n\t\r\n\t// remainder \r\n\tlet remainder \u003d 43 % 5; \r\n}\r\n"},{"type":"text","value":"Operacje numeryczne muszą być wykonywane na tym samym typie:"},{"type":"code","value":"fn main() {     \r\n\tlet x \u003d 2u32;\r\n\tlet y \u003d 5u8; \r\n\tlet z \u003d x + y; // compile error\r\n}"},{"type":"text","value":"Rzutowanie typów:\n"},{"type":"code","value":"fn main() {     \r\n\tlet x \u003d 2u32;\r\n\tlet y \u003d 5u8; \r\n\tlet z \u003d x + y as u32; // ok\r\n}"},{"type":"text","value":"### Typ logiczny\n"},{"type":"code","value":"fn main() {\r\n    let t \u003d true;\r\n    let f: bool \u003d false; // with explicit type annotation\r\n}"},{"type":"text","value":"### Typ znakowy\n\nWartości znakowe (char) definiujemy za pomocą pojedynczego cudzysłowia. Wartość znakowa zajmuje 4 bajty, jest definiowana w standardzie Unicode. \n\n"},{"type":"code","value":"fn main() {\r\n\tlet ch1 \u003d \u0027a\u0027;\r\n\tlet ch2 : char \u003d \u0027b\u0027;\r\n\tlet ch3 \u003d \u0027™\u0027; // utf chars\r\n}"}]},{"title":"Typy złożone","cells":[{"type":"text","value":"## Typy złożone\n\n### Krotki\n\nŹródło: https://doc.rust-lang.org/rust-by-example/primitives/tuples.html\n\nKrotka to niemodyfikowalna sekwencja wartości różnego typu. Krotki tworzymy za pomocą `()`, a każda krota ma typ wyrażony jako:  `(T1, T2, ...)`, gdzie `T1`, `T2` oznacza typy poszczególnych elementów krotki. \n"},{"type":"code","value":"fn main() {\r\n    // A tuple with a bunch of different types.\r\n    let long_tuple \u003d (1u8, 2u16, 3u32, 4u64,\r\n                      -1i8, -2i16, -3i32, -4i64,\r\n                      0.1f32, 0.2f64,\r\n                      \u0027a\u0027, true);\r\n\r\n    // Values can be extracted from the tuple using tuple indexing.\r\n    println!(\"Long tuple first value: {}\", long_tuple.0);\r\n    println!(\"Long tuple second value: {}\", long_tuple.1);\r\n\r\n    // Tuples can be tuple members.\r\n    let tuple_of_tuples \u003d ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);\r\n\r\n    // Tuples are printable.\r\n    println!(\"tuple of tuples: {:?}\", tuple_of_tuples);\r\n\r\n    // But long Tuples (more than 12 elements) cannot be printed.\r\n    //let too_long_tuple \u003d (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);\r\n    //println!(\"Too long tuple: {:?}\", too_long_tuple);\r\n    // TODO ^ Uncomment the above 2 lines to see the compiler error\r\n\r\n    let pair \u003d (1, true);\r\n    println!(\"Pair is {:?}\", pair);\r\n\r\n    // To create one element tuples, the comma is required to tell them apart\r\n    // from a literal surrounded by parentheses.\r\n    println!(\"One element tuple: {:?}\", (5u32,));\r\n    println!(\"Just an integer: {:?}\", (5u32));\r\n\r\n    // Tuples can be destructured to create bindings.\r\n    let tuple \u003d (1, \"hello\", 4.5, true);\r\n\r\n    let (a, b, c, d) \u003d tuple;\r\n    println!(\"{:?}, {:?}, {:?}, {:?}\", a, b, c, d);\r\n\r\n}"},{"type":"text","value":"### Tablice\n\nŹródło: https://doc.rust-lang.org/rust-by-example/primitives/array.html\n\nTablica to sekwencja elementów tego samego typu (w odróżnieniu od krotki), przechowywane w ciągłej obszarze pamięci. Tablice tworzymy za pomocą `[]`, a jej długość musi być znana podczas kompilacji. Typ tablicy składa się z typu jej elementów oraz długości: `[T; length]`.\n"},{"type":"code","value":"use std::mem;\r\n\r\nfn main() {\r\n    // Fixed-size array (type signature is superfluous).\r\n    let xs: [i32; 5] \u003d [1, 2, 3, 4, 5];\r\n\r\n    // All elements can be initialized to the same value.\r\n    let ys: [i32; 500] \u003d [0; 500];\r\n\r\n    // Indexing starts at 0.\r\n    println!(\"First element of the array: {}\", xs[0]);\r\n    println!(\"Second element of the array: {}\", xs[1]);\r\n\r\n    // `len` returns the count of elements in the array.\r\n    println!(\"Number of elements in array: {}\", xs.len());\r\n\r\n    // Arrays are stack allocated.\r\n    println!(\"Array occupies {} bytes\", mem::size_of_val(\u0026xs));\r\n\r\n    // Arrays can be safely accessed using `.get`, which returns an\r\n    // `Option`. This can be matched as shown below, or used with\r\n    // `.expect()` if you would like the program to exit with a nice\r\n    // message instead of happily continue.\r\n    for i in 0..xs.len() + 1 { // Oops, one element too far!\r\n        match xs.get(i) {\r\n            Some(xval) \u003d\u003e println!(\"{}: {}\", i, xval),\r\n            None \u003d\u003e println!(\"Slow down! {} is too far!\", i),\r\n        }\r\n    }\r\n\r\n    // Out of bound indexing causes runtime error.\r\n    //println!(\"{}\", xs[5]);\r\n}"}]},{"title":"Podstawowe wyrażenia i instrukcje","cells":[{"type":"text","value":"## Podstawowe wyrażenia i instrukcje\n\n### Wyrażenie warunkowe\n"},{"type":"text","value":"- if\n- if /else; if / else if / else\n- expression \n\n### Pętla `loop`\n\n### Pętla `while`\n\n### Pętla `for`\n"}]}]}]}